= アーキテクチャ固有のお話

この章では, 前章で解説した一般的なPlan 9 アセンブラ共通のお作法から
外れる箇所を i386, amd64 のそれぞれについて取り上げます. 

== i386

8a は x86 32bit (i386) アーキテクチャ向けのアセンブラです. 
基本的にはこのアセンブラはプロテクトモードで動作するコードのアセンブル用
であることが前提となっています. 
x86 固有のお話としてはレジスタそして命令セットにおける差分に分けられます. 


=== 利用可能なレジスタ

レジスタとしては SP, AX, BX, CX, DX, BP, DI, SI というシンボルで
いわゆる x86 の汎用データレジスタにアクセスすることができます. 
同様にセグメントレジスタ (CS, DS, ES, FS, GS, SS)や
CR0, CR3といった制御レジスタ, GDTR, IDTRに類される各種
システムテーブルポインタレジスタへのアクセスもサポートされています. 


コンパイラ, アセンブラそしてリンカで規定されるこれらのレジスタの
利用方法は以下の通りです. スタックポインタは SP に保持されます. 
サブルーチン等の返値には AX を用います. 物理的なフレームポインタとして
x86 には BP (ebp) が存在しますがそちらは使わず FP利用します. 

//list[8a_RET][AXを用いた返値の例: getcr0 (src/9/pc/l.s)]{
TEXT getcr0(SB), $0         /* CR0 - processor control */
        MOVL    CR0, AX
        RET
//}

x86 的には正式な32bit幅レジスタの名称は @<strong>{E} 
をプレフィクスとした名前 (e.g. EAX, ESP) ですが, 8a では定義されておらず
使えません. ビット幅については第2章で述べたロード・ストアを担当する MOV 
疑似命令のサフィクスをもって判断されます. 
@<list>{8a_MOV_bit_width} に eax (8a では AX) から ebx (8a では BX) に値を
格納する際の例を記載します. 
特筆すべきは例3と例4が同じオペレーションであることです. 
MOVのサフィクスによる幅指定は下位からの幅であることに注意する必要があります. 
AH などの上位にアクセスしたい場合は明示的にこのレジスタを指定する必要があります. 

//list[8a_MOV_bit_width][MOVのサフィクス切り替えによる]{
# 例1. 32bit 幅のMOV : eax から ebx (32bit 全体)
MOVL	AX, BX

# 例2. 16bit 幅のMOV : ax から bx (下16bit)
MOVW	AX, BX

# 例3. 8bit 幅のMOV : al から bl (下8bit)
MOVB	AX, BX

# 例4. 8bit 幅のMOV : al から bl (下8bit)
MOVB	AL, BL

# 例5. 8bit 幅のMOV : ah から bh (下位16bit幅中の上8bit)
MOVB	AH, BH
//}

これらのMOVとレジスタの柔軟な関係は基本的には汎用レジスタに限ったものであり
その他の32bit幅が前提であるレジスタでは不正なものと見なされます. 
たとえば MOVB BP, DI といった格納は基本的には不正なものです. 


=== 命令セット

命令セットは一部を除き, Intel Software Developer's Manual に記載されたもの
を用いることができます. 前章でも述べたとおりニーモニックは全て大文字である
必要があります. "一部" の例外はロード、ストア命令および分岐命令です. 
先のレジスタの節でもMOV疑似命令について触れましたが, Plan 9のアセンブラでは
レジスタ, メモリを問わず値の移動には MOV 疑似命令を用います. 
とはいえ gas や NASM でもi386 では基本的には同様のニーモニックである mov 命令で
まかなえているのでこのあたりは大きな差異ではないでしょう. 

例外として分岐命令があります. x86 では JO , JNO といった分岐命令を定義しています
がこれらを使うことはできません. 8a では 2a つまり MC68020 向けの分岐命令
のみがサポートされています. このため JO, JNO, JB, JNB, JZ, JNZ, JBE, JNBE, JS, 
JNS, JP, JNP, JL, JNL, JLE, JNLE といった x86 向けの分岐命令は
JOS, JOC, JCS, JCC, JEQ, JNE, JLS, JHI, JMI, JPL, JPS, JPC, JLT, JGE, JLE, JGT
と書く必要があります. 


その他ニーモニック自体ではなく使い方に影響のあるものを以下に挙げます. 
JMP や CALL は x86 のそれと同じく用いることができますが,
@<strong>{JMP*} のように @<strong>{*} (アスタリスク)が後置されている場合が
あります. これらは絶対番地へのジャンプに用いられます. 
@<list>{8a_JMP_asterisk}は, カーネルを起動するにあたり絶対番地に飛ぶために
これを用いている例です. このような低レイヤの処理でのみ用いられる傾向にあります.

//list[8a_JMP_asterisk][アスタリスク付きのJMPの例 (src/9/pc/l.s)]{
TEXT _startKADDR(SB), $0
        MOVL    $_startPADDR(SB), AX
        ANDL    $~KZERO, AX
        JMP*    AX
//}


x86 には指定回数分だけ第1オペランドの命令を繰り返し実行する rep 命令が
存在します. gas では@<list>{8a_REP}上部のように利用されます. 
8a でも REP, REPN はニーモニックとして定義されていますが, プレフィクス的に
用いることはできません. 
例の下部に上げたようにあたかも個別の独立した命令であるように書く必要があります. 
多くの例では @<strong>{;} (セミコロン)で区切って後置しているかのように記述
をすることが多いようです(@<list>{8a_insb}に挙げる insb サブルーチンなど). 
#@# 前述のとおり 8a ではセミコロンは区切り文字であることにご注意ください. 


//list[8a_REP][rep命令の利用例: 6回 movsb を繰り返す]{
/* gas の場合 */
  mov $6, %ecx
  rep movsb

/* 8a の場合 */
  MOV $6, CX
  REP; MOVSB
//}

//list[8a_insb][rep命令の利用例: insbサブルーチン (src/9/pc/l.s)]{
TEXT insb(SB), $0
        MOVL    port+0(FP), DX
        MOVL    address+4(FP), DI
        MOVL    count+8(FP), CX
        CLD
        REP;    INSB         /* ここで INSB を CX 回繰り返す */
        RET
//}

== amd64

amd6 用のアセンブラ 6a も基本的なところは 8a と同じです. 
ここでは i386 との差異がある部分のみ記載します. 

=== レジスタの種類における差異

レジスタの種類としては基本的には 8a, i386 のそれと同様のレジスタが64bit幅に
拡充されたものとして利用できます. 
amd64 では 64bit 幅の汎用レジスタは rax, rbx という名前で定義されていますが,
6a ではこれらは存在せず 32bit 幅の場合と区別すること無く AX, BX といったシンボル
を用います. 


6a では MMX および MMX および XMM の命令セットが追加されておりそれぞれのレジスタ
が M0〜M7 および X0〜X15 として割当たっています. 
また固定小数演算用のレジスタとして R8〜R15 が割り当てられています. 
この R ではじまるレジスタ名は MC68020 のアセンブラで用いられている
データレジスタの表記方法ですが, amd64 のそれではこのように外部レジスタの
割当先として R15 以下の名前を利用しています. 


=== 使い方における差異

前述の通り 64bit 幅レジスタ用に特別な名前は存在しないため,
MOV 疑似命令のサフィクスを以て操作するビット幅を決定します. 
その他のサフィクスを用いる命令を含め 64bit 幅用には @<strong>{Q} (Quad) 
を付与することでこれを指定します. 
また 128 bit 幅での操作では @<strong>{O} (Octo) を付与することとしています. 
Intel のマニュアルでは 128bit 幅向けには O, DQ など様々なサフィクスが
存在しますが 6a ではこれに統一されています. 
XMM の命令でも同じく L, Q, O などを用いますが一部の場合に PL (Packed Long) を
Q, DQ, PI の代わりとして用いることがあります. 
いずれの場合も, 浮動小数点用のレジスタへのロード/ストア命令にも MOV を利用する
ことができ具体的な実装はアセンブラにて抽象化されます. 


amd64 では AX 等のレジスタが64bit幅になるため MOVL, MOVW などの狭いMOV疑似命令を
用いた場合に実際に格納される値について注意が必要です. 
これらのオペレーションではでは指定されたビット幅分のみ下位からコピーされます. 
それ以外の上位ビットはゼロクリアされます. 

型にも気を付ける必要があります. 即値としてのオペランドは符号付き 32bit 整数に
限定されており 64bit 幅の操作を行う時のみ符号付き 64bit 整数として扱われます. 
例外として MOVQ のオペランドとなる場合のみ即値として 64bit 整数が記述できます. 


サブルーチン呼び出しの場合における値の受け渡しについても注意が必要です. 
i386 (8a) と異なる点として, 第１引数が整数値またはポインタの場合はレジスタでの
値渡しとなりこれに BP レジスタが使われます. 簡便のため RARG なる名前が
用意されておりこれで第１引数を参照することができます(@<list>{6a_insb}). 
逆にサブルーチンを呼ぶ場合には, RARG に値を格納する必要があります. 

//list[6a_insb][RARGの利用例: insb サブルーチン (src/9/pc/l.s)]{
TEXT inb(SB), 1, $-4
        MOVL    RARG, DX   /* MOVL port+0(FP), DX */
        XORL    AX, AX
        INB
        RET
//}


サブルーチンの返値に AX を用いるのは 8a と共通です. @<list>{6a_insb} の例でも
INB の結果 が AX に値が格納されるためそのまま RET 命令にて呼び出し元に
戻っています. この例とは異なり浮動小数点の返値は X0 にて渡すこととされています. 
ただしこの例は少なく, @<list>{6a_sqrt} に挙げる sqrt() のみでしか用いられていません. 

//list[6a_sqrt][X0による返値の例: sqrt() (src/libc/amd64/sqrt.s)]{
sqrt(SB), $0
        MOVSD   a+0(FP), X0
        SQRTSD  X0, X0
        RET
//}

なおこの例では SQRTSD つまり XMM での浮動小数点演算命令が明示的に
使われています. 歴史的に x86 には x87 なる浮動小数点演算を行うコプロセッサが
付属しており, XMM ではなくそちらを明示的に使うことも可能です. 
たとえば sqrt 相当の演算には XMM 側の SQRTSD に加えて x87 側の
AFSQRT なる命令も定義されています. 
ただしこのようにアセンブラ側で明示的に指定している場合を除いて, C コンパイラ
(8c, 6c) やリンカ (8l, 6l) では XMM 命令セットを用いるようになっています. 


