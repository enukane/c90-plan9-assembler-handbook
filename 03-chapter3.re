= アーキテクチャ固有のお話

この章では, 前章で解説した"一般的な" Plan 9 アセンブラのお作法から
外れる箇所について i386, amd64 のそれぞれにて取り上げます.

== i386

8a は i386, x86 32bit アーキテクチャ向けのアセンブラです.
基本的にはこのアセンブラはプロテクトモードで動作するコードのアセンブル用
であることが前提となっています.
x86 固有のお話としてはレジスタそして命令セットにおける差分に分けられます.


=== 利用可能なレジスタ

レジスタとしては SP, AX, BX, CX, DX, BP, DI, SI というシンボルで
いわゆる x86 の汎用データレジスタにアクセスすることができます.
同様にセグメントレジスタ (CS, DS, ES, FS, GS, SS)や
CR0, CR3といった制御レジスタ, GDTR, IDTRに類される各種
システムテーブルポインタレジスタへのアクセスもサポートされています.


コンパイラ, アセンブラそしてリンカで規定されるこれらのレジスタの
利用方法は以下の通りです: スタックポインタは SP に保持されます.
サブルーチン等の返値には AX を用います. 物理的なフレームポインタは
x86 にはありませんが FP を疑似レジスタとして利用することができます.


//list[8a_RET][AXを用いた返値の例: getcr0 (src/9/pc/l.s)]{
TEXT getcr0(SB), $0         /* CR0 - processor control */
        MOVL    CR0, AX
        RET
//}

x86 的には汎用データレジスタの正式な32bit幅レジスタの名称は "E"
をプレフィクスとした名前(e.g. "EAX")ですが, 8a ではこれを用いません.
ビット幅についてはロード・ストアを担当する MOV 疑似命令のサフィクス
を持って判断されます.
32bit幅出あれば "L" (Long), 16bit幅であれば "W" (Word), 8bit幅であれば
"B" (Byte) を付与します.
@<list>{8a_MOV_bit_width} に EAX(AX) から BX(EBX, BL) に値を
格納する際の例を記載します.
特筆すべきは例3と例4が同じオペレーションであることです.
MOVのサフィクスによる幅指定は下位からの幅であることに注意する必要があります.
AH などの上位にアクセスしたい場合は明示的にこのレジスタを指定する必要があります.

//list[8a_MOV_bit_width][MOVのサフィクス切り替えによる]{
# 例1. 32bit 幅のMOV : eax から ebx (32bit 全体)
MOVL	AX, BX

# 例2. 16bit 幅のMOV : ax から bx (下16bit)
MOVW	AX, BX

# 例3. 8bit 幅のMOV : al から bl (下8bit)
MOVB	AX, BX

# 例4. 8bit 幅のMOV : al から bl (下8bit)
MOVB	AL, BL

# 例5. 8bit 幅のMOV : ah から bh (下位16bit幅中の上8bit)
MOVB	AH, BH
//}

これらのMOVとレジスタの柔軟な関係は基本的には汎用レジスタに限ったものであり
その他の32bit幅が前提であるレジスタでは不正なものと見なされます.
たとえば MOVB BP, DI といった格納は基本的には不正なものです.
ただし MOVはあくまで疑似命令であるため

=== 命令セット

命令セットは一部を除き, Intel Software Developer's Manual に記載されたもの
を用いることができます. 前章でも述べたとおりニーモニックは全て大文字である
必要があります.
"一部" の例外はロード、ストア命令および分岐命令です.


先のレジスタの節でもMOV疑似命令について触れましたが, Plan 9のアセンブラでは
レジスタ, メモリを問わず値の移動には MOV 疑似命令を用います.
とはいえ gas や NASM でも基本的には同様のニーモニックである mov 命令で
まかなえているのでこのあたりは大きな差異ではないでしょう.


分岐命令はこれに比べれば大きな差分です. x86 では JO , JNO といった
分岐命令を定義していますがこれらを使うことはできません.
8a では 2a つまり MC68020 向けの分岐命令シンボルのみがサポートされています.
このため JO, JNO, JB, JNB, JZ, JNZ, JBE, JNBE, JS, JNS, JP, JNP, JL, JNL,
JLE,
JNLE といった分岐命令は
JOS, JOC, JCS, JCC, JEQ, JNE, JLS, JHI, JMI, JPL, JPS, JPC, JLT, JGE, JLE, JGT
と書く必要があります.


その他ニーモニック自体ではなく使い方に影響のあるものを以下に挙げます.
JMP や CALL は x86 のそれと同じく用いることができますが,
"JMP*" のように "*" (アスタリスク)が後置されている場合があります.
これらは絶対番地へのジャンプ等に用いられます.
@<list>{8a_JMP_asterisk}は, この例としてカーネルを起動するにあたり
絶対番地に飛ぶために用いられておりこのような起動時の処理などでのみ用いられます.

//list[8a_JMP_asterisk][アスタリスク付きのJMPの例 (src/9/pc/l.s)]{
TEXT _startKADDR(SB), $0
        MOVL    $_startPADDR(SB), AX
        ANDL    $~KZERO, AX
        JMP*    AX
//}


x86 には指定回数分だけ第1オペランドの命令を繰り返し実行する rep 命令が
存在します. これは通常@<list>{8a_REP}のように利用されます.
8a でも REP, REPN を用いることができますが, このようにプレフィクス的に
用いることができません. 
このため例にもあるようにあたかも個別の独立した命令であるように書く必要があります.
多くの例では ";" (セミコロン)で区切って後置しているかのように記述
をすることが多いようです(@<list>{8a_insb}に挙げる insb サブルーチンなど).
8a では ";" はコメントを意味しないことに注意しましょう.


//list[8a_REP][rep命令の利用例: 6回 movsb を繰り返す]{
# gas 等の場合
  mov ecx,6
  rep movsb

# 8a での利用例
  MOV $6, CX
  REP; MOVSB
//}

//list[8a_insb][rep命令の利用例: insbサブルーチン (src/9/pc/l.s)]{
TEXT insb(SB), $0
        MOVL    port+0(FP), DX
        MOVL    address+4(FP), DI
        MOVL    count+8(FP), CX
        CLD
        REP;    INSB         /* ここで CX 回繰り返す */
        RET
//}

== amd64

amd6 用のアセンブラ 6a の基本的なところは 8a と同じです.
ここでは i386 との差異がある部分のみ記載します.

=== レジスタの種類における差異

レジスタの種類としては基本的には 8a, i386 のそれと同様のレジスタが64bit幅に
拡充されたものとして利用できます.
amd64 では 64bit 幅の汎用レジスタは rax, rbx という名前で定義されていますが,
6a ではこれらは存在せず 32bit 幅の場合と区別すること無く AX, BX といったシンボル
を用います.


6a では MMX および MMX および XMM の命令セットが追加されておりそれぞれのレジスタ
が M0〜M7 および X0〜X15 として割当たっています.
また固定小数演算用のレジスタとして R8〜R15 が割り当てられています.
この R ではじまるレジスタ名は MC68020 のアセンブラで用いられている
データレジスタの表記方法ですが, amd64 のそれではこのように外部レジスタの
割当先として R15 以下の名前を利用しています.


=== 使い方における差異

前述の通り 64bit 幅レジスタ用に特別な名前は存在しないため,
MOV 疑似命令のサフィクスを以て操作するビット幅を決定します.
その他のサフィクスを用いる命令を含め 64bit 幅用には "Q" (Quad) を付与することで
これを指定します.
また 128 bit 幅での操作では "O" (Octo) を付与することとしています.
Intel のマニュアルでは O, DQ など様々なサフィクスが存在しますが, 6a では
これに統一されています.
XMM の命令でも同じく L, Q, O などを用いますが一部の場合に PL (Packed Long) を
Q, DQ, PI の代わりに用いることがあります.
いずれの場合も, 浮動小数点用のレジスタへのロード/ストア命令には MOV を利用する
ことができ詳細はアセンブラにて抽象化されます.


AX 等のレジスタが64bit幅になるため MOVL, MOVW などの狭いMOV疑似命令を
用いた場合に実際に格納される値について注意が必要です.
これらのオペレーションではでは指定されたビット幅分のみ下位からコピーされます.
それ以外の上位ビットはゼロクリアされます.

型にも気を付ける必要があります. 即値としてのオペランドは符号付き 32bit 整数に
限定されており 64bit 幅の操作を行う時のみ符号付き 64bit 整数として扱われます.
例外として MOVQ のオペランドとなる場合のみ即値として 64bit 整数が記述できます.


サブルーチン呼び出しの場合における値の受け渡しについても注意が必要です.
i386 (8a) と異なる点として, 第１引数が整数値またはポインタの場合はレジスタでの
値渡しとなりこれに BP レジスタが使われます. 簡便のため RARG なる名前が
用意されておりこれで第１引数を参照することができます(@<list>{6a_insb}).
逆にサブルーチンを呼ぶ場合には, RARG に値を格納する必要があります.

//list[6a_insb][RARGの利用例: insb サブルーチン (src/9/pc/l.s)]{
TEXT inb(SB), 1, $-4
        MOVL    RARG, DX   /* MOVL port+0(FP), DX */
        XORL    AX, AX
        INB
        RET
//}


サブルーチンの返値に AX を用いるのは 8a と共通です. @<list>{6a_insb} の例でも
INB の結果 AX に値が格納されるためそのまま RET 命令にて呼び出し元に戻っています.
この例とは異なり浮動小数点の返値は X0 にて渡すこととされています.
ただしこの例は少なく, @<list>{6a_sqrt} に挙げる sqrt() のみでしか用いられていません.

//list[6a_sqrt][X0による返値の例: sqrt() (src/libc/amd64/sqrt.s)]{
sqrt(SB), $0
        MOVSD   a+0(FP), X0
        SQRTSD  X0, X0
        RET
//}

なおこの例では SQRTSD つまり XMM での浮動小数点演算命令が明示的に
使われています. 歴史的に x86 には x87 なる浮動小数点演算を行うコプロセッサが
付属しており, XMM ではなくそちらを明示的に使うことも可能です.
たとえば sqrt 相当の演算には XMM 側の SQRTSD に加えて x87 側の
AFSQRT なる命令も定義されています.
ただしこのようにアセンブラ側で明示的に指定している場合を除いて, C コンパイラ
(8c, 6c) やリンカ (8l, 6l) では XMM 命令セットを用いるようになっています.


