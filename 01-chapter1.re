= Plan 9 におけるアセンブラ

== Plan 9 でサポートされるアーキテクチャ

Plan 9では MIPS, SPARC, i960, amd 29000, Motorola 68020, 68000, ppc, alpha,
arm, i386, amd64 など様々なアークテクチャをサポートしています@<fn>{once_arch}. 

//footnote[once_arch][ここに並べた大半は 「かつてはしていました」になってしまいましたが...]

コンパイラなどプログラムのビルドに関わるツールは
「アーキテクチャを示す1文字 + ツールの種類1文字」という規則で命名されています. 
アーキテクチャを示す1文字には主に数字(たまにアルファベット)が用いられます
@<fn>{once_arch}. それぞれの文字が対応するアーキテクチャを以下に記載します. 

//footnote[arch_O][アスタリスク代わりに 'O' で代替表記することもあります]

 * 0: MIPS 3000 (リトルエンディアン), 消滅
 * 1: Motorola MC68000
 * 2: Motorola MC68020
 * 5: ARM(リトルエンディアン)
 * 6: amd64 (かつてはi960用だった＠Plan 9本家)
 * 7: Alpha, 消滅
 * 8: Intel i386, i486, Pentium, e.t.c
 * 9: 64bit PowerPC, AMD Am29000, 消滅
 * k: Sun SPARC
 * q: PowerPC
 * v: MIPS 3000 (ビッグエンディアン)


@<string{消滅} と末尾に付記したアーキテクチャは, 各種ドキュメントにその記録が
あるものの9front や Plan 9 4th Edition ではソースコード (src/cmd/ の下) から
コンパイラ等が消えていしまっているものです. 


実際のところ, 9front カーネルがサポートしているアーキテクチャ/ターゲットボードは
以下の11種類です. すでに 4th Edition の時点で SPARC や Alpha, MIPS の
サポートはなくなり, 代わりに Raspberry Pi など新しめのボードのサポートが
追加されているのが見て取れます. 

 * bcm: ARM (5a) Broadcom (Raspberry Pi) 用
 * kw: ARM (5a) Marvell Kirkwood (Sheevaplugなど)用
 * mtx: PowerPC (qa)
 * omap: ARM (5a)
 * pc : i386 (8a)
 * pc64: amd64 (6a)
 * ppc: PowerPC (qa)
 * sgi: MIPS (va)
 * teg2: ARM (5a) NVIDIA Tegra2 (Compulab Trim-Slice シリーズ用)
 * xen: i386 (8a) Xen 仮想化環境用
 * zynq: ARM (5a) Zynq-7000 用

これらのターゲットに併せて適切なプレフィクスをもつツールを選択する必要
があります. 

== Plan 9 プログラミング環境でのアセンブラ

プログラミング環境というと大げさですが, プログラマが書いたコードを
実行形式に落とし込むためのツールとして, 他のプラットフォームのそれと同じく
C言語のコンパイラ, アセンブラ, ローダ(リンカ)がそれぞれ用意されています. 


先に述べたとおりこれらのツールは
「アーキテクチャを示す1文字 + ツールの種類1文字」の名前が付けられています. 
ツールの種類1文字としてコンパイラは @<strong>{c}, アセンブラは @<strong>{a}, 
そして ローダは @<strong>{l} を用います. 
この規則に従い, i386 では C コンパイラは @<strong>{8c}, アセンブラは
@<strong>{8a}, ローダは @<strong>{8l} となります. 


使い方も特に UNIX 系の OS での gcc や cc の使い方とは変わらず,
@<list>{plan9_8c_usage} や @<list>{plan9_8a_usage} に記載したように
オブジェクトファイル (標準で @<em>{*.O} に出力される) に落とし込み,
次にローダ(リンカ)で実行ファイルとして出力するといった流れです. 


//list[plan9_8c_usage][コンパイラでのコンパイル]{
/* コンパイラの実行: hello.c からオブジェクトファイル hello.8 を生成する */
% 8c  hello.c

/* ローダの実行: hello.8 から実行ファイル hello_world を生成する */
% 8l  –o  hello_world  hello.8  # 実行ファイル hello_world が生成される
//}

//list[plan9_8a_usage][アセンブラの利用例]{
/* アセンブラの実行: hello.S からオブジェクトファイル hello.S.8 を生成する */
$ 8a  hello.S

/* ローダの実行: hello.S.8 から実行ファイル hello_world を生成する */
$ 8l  -o hello_world  hello.S.8
//}

特異なところとしては他のプラットフォームではリンカと呼称する役割のツール
8l がローダと呼ばれるところでしょうか. 
役割としてはリンカと同じくオブジェクトファイルまたはライブラリのリンク,
そして実行ファイルの形成と出力を行います. 
ローダという名前付けは, 実行ファイル形式へと各オブジェクトファイル上のコードを
ロードして配置していくという処理を元になされています. 


「実行ファイルへのロード」の処理において様々な処理をローダは行っており
その中で特筆すべきこととして以下が挙げられます. 
まずローダでは分岐を畳んだり, 部分的にコピーしてこれを消したり, 
不到達コードを排除したりといった最適化を行う場合があります. 
また NOP 疑似命令を消し飛ばすといったことも行います. 
これは Plan 9 での NOP 疑似命令 (機械語でのNOPにあらず) は「何もしない」ではなく
「命令がない」ことを示すために定義されていることに起因します. 



