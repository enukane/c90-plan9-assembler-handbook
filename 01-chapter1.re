= Plan 9 におけるアセンブラ

== Plan 9 でサポートされるアーキテクチャ

Plan 9では MIPS, SPARC, i960, amd 29000, Motorola 68020, 68000, ppc, alpha,
arm, i386, amd64 など様々なアークテクチャをサポートしています
(あるいはしていました).

コンパイラなどプログラムのビルドに関わるツールは
「アーキテクチャを示す1文字 + ツールの種類1文字」という規則で命名されています.
アーキテクチャを示す1文字には主に数字(たまにアルファベット)が用いられ,
"O" で代替されることが多いです. それぞれの文字が対応するアーキテクチャを
以下に記載します.

* 0: MIPS 3000 (リトルエンディアン), 消滅
* 1: Motorola MC68000
* 2: Motorola MC68020
* 5: ARM(リトルエンディアン)
* 6: amd64 (かつてはi960用だった＠Plan 9本家)
* 7: Alpha, 消滅
* 8: Intel i386, i486, Pentium, e.t.c
* 9: 64bit PowerPC, AMD Am29000, 消滅
* k: Sun SPARC
* q: PowerPC
* v: MIPS 3000 (ビッグエンディアン)


"消滅"と末尾に付記したアーキテクチャは, 各種ドキュメントにその記録があるものの
9front や Plan 9 4th Edition ではソースコード(src/cmd/以下)からコンパイラ等が
消えていしまっているものです.

実際のところ, 9front カーネルがサポートしているアーキテクチャ/ターゲットボードは
以下の11種類です. すでに 4th Edition の時点で SPARC や Alpha, MIPS の
サポートはなくなり, 代わりに Raspberry Pi など新しめのボードのサポートが
追加されているのが見て取れます.

* bcm: ARM (5a) Broadcom (Raspberry Pi) 用
* kw: ARM (5a) Marvell Kirkwood (Sheevaplugなど)用
* mtx: PowerPC (qa)
* omap: ARM (5a)
* pc : i386 (8a)
* pc64: amd64 (6a)
* ppc: PowerPC (qa)
* sgi: MIPS (va)
* teg2: ARM (5a) NVIDIA Tegra2 (Compulab Trim-Slice シリーズ用)
* xen: i386 (8a) Xen 仮想化環境用
* zynq: ARM (5a) Zynq-7000 用

これらのターゲットに併せて適切なプレフィクスをもつツールを選択する必要
があります.

== Plan 9 プログラミング環境でのアセンブラ

プログラミング環境というと大げさですが, プログラマが書いたコードを
実行形式に落とし込むためのツールとして, 他のプラットフォームのそれと同じく
C言語のコンパイラ, アセンブラ, ローダ(リンカ)がそれぞれ用意されています.

先に述べたとおりこれらのツールは
「アーキテクチャを示す1文字 + ツールの種類1文字」の名前が付けられています.
ツールの種類1文字としてコンパイラは "c", アセンブラは "a" そして ローダは
"l" を用います. たとえば i386 では C コンパイラは 8c, アセンブラは 8a, 
ローダは 8l となります.

使い方も特に UNIX 系の OS での gcc や cc の使い方とは変わらず,
@<list>{plan9_8c_usage} や @<list>{plan9_8a_usage} に記載したように
オブジェクトファイル (標準で "*.O" に出力される) に落とし込み,
次にローダ(リンカ)で実行ファイルとして出力するといった流れです.


//list[plan9_8c_usage][コンパイラでのコンパイル]{
% 8c  hello.c                   # hello.8 および sub.8 が生成される
% 8l  –o  hello_world  hello.8  # 実行ファイル hello_world が生成される
//}

//list[plan9_8a_usage][アセンブラの利用例]{
$ 8a  hello.S                    # hello.S.8 が生成される
$ 8l  -o hello_world  hello.S.8  # 実行ファイル hello_world が生成される
//}

特異なところとしては他のプラットフォームではリンカと呼称する役割のツール
8l がローダと呼ばれるところでしょうか.
役割としてはリンカと同じくオブジェクトファイルまたはライブラリのリンク,
そして実行ファイルの形成と出力を行います. この, 実行ファイルへ各種オブジェクト
ファイル上のコードをロードしていくという部分に力点が置かれているため
ローダという名前を取っています.


「実行ファイルへのロード」の処理において様々な処理をローダは行っており
その中で特筆すべきこととして以下が挙げられます. 
まずローダでは分岐を畳んだり, 部分的にコピーしてこれを消したり, 
不到達コードを排除したりといった最適化を行う場合があります.
また NOP 疑似命令を消し飛ばすといったことも行います.
Plan 9での NOP 疑似命令 (!= 機械語でのNOP) は、「何もしない」ではなく
「命令がない」ことを示すために NOP が定義されていることに起因します.



